<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Reflection</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Reflection</h1><br/><p>В Java существует специальный служебный класс, по имени “Class”. Этот класс представляет характеристики класса, экземпляром которого является объект. Он хранит информацию о том, является ли объект на самом деле интерфейсом, массивом или примитивным типом, каков суперкласс объекта, каково имя класса, какие в нем конструкторы, поля, методы и вложенные классы.</p><p></p><p><h3>Получение класса “Class”</h3></p><p><div class="codebox"><pre>String s = <span style="color:#3ad900;font-weight:400">&quot;Это строка&quot;</span>;<br />Class с = s.getClass();<span style="color:#0088ff;font-weight:400">// получение информации о классе String</span><br /><br />Статический метод forName(string <span style="color:#7f0044;font-weight:400">class</span>)<br />возвращает объект класса <span style="color:#7f0044;font-weight:400">class</span> для класса, <br />указанного в аргументе, например:<br />Class cl = Class.forName(<span style="color:#3ad900;font-weight:400">&quot;java.lang.String&quot;</span>);<br />Также можно получить объект класса Class <br />добавив к имени класса через точку ключевое слово <span style="color:#7f0044;font-weight:400">class</span>:<br />Class c2 = java.lang.String.<span style="color:#7f0044;font-weight:400">class</span>;Метод getSuperclass() возвращает суперкласс объекта ссылочного типа<br />getPackage() — пакет<br />Получение имени класса:<br />Class c = myObject.getClass();<br />String s = c.getName();<span style="color:#0088ff;font-weight:400">// возвращает полное имя класса, </span><br />            		вместе со всеми пакетами</pre></div></p><p>            </p><p>Работа с рефлексией может вызывать большое количество исключений. Поэтому классы, которые работают с рефлексией, лучше заворачивать в какие-то утилитарные классы, и обрабатывать исключения в более удобной форме.</p><p></p><p><h3>Исследование модификаторов класса</h3></p><p><div class="codebox"><pre>MyClass obj = <span style="color:#ff9d00;font-weight:700">new</span> MyClass();<br />Class c =  obj.getClass();<br /><span style="color:#7f0044;font-weight:400">int</span> mods = c.getModifiers();<br /><span style="color:#ff9d00;font-weight:700">if</span> (Modifier.isPublic(mods)) {<br />    System.out.println(<span style="color:#3ad900;font-weight:400">&quot;public&quot;</span>);<br />}<br /><span style="color:#ff9d00;font-weight:700">if</span> (Modifier.isAbstract(mods)) {<br />    System.out.println(<span style="color:#3ad900;font-weight:400">&quot;abstract&quot;</span>);<br />}<br /><span style="color:#ff9d00;font-weight:700">if</span> (Modifier.isFinal(mods)) {<br />    System.out.println(<span style="color:#3ad900;font-weight:400">&quot;final&quot;</span>);</pre></div></p><p><h3>Определение реализуемых интерфейсов</h3></p><p><div class="codebox"><pre>Class c =  LinkedList.<span style="color:#7f0044;font-weight:400">class</span>;<br />Class[] interfaces = c.getInterfaces();<br /><span style="color:#ff9d00;font-weight:700">for</span>(Class cInterface : interfaces) {<br />    System.out.println( cInterface.getName() );<br />}</pre></div></p><p><h3>Получение и установка значений полей</h3></p><p><div class="codebox"><pre>Class c = obj.getClass();<br />Field[] publicFields = c.getFields();<br /><span style="color:#ff9d00;font-weight:700">for</span> (Field field : publicFields) {<br />    Class fieldType = field.getType();<br />    System.out.println(<span style="color:#3ad900;font-weight:400">&quot;Имя: &quot;</span> + field.getName());<br />    System.out.println(<span style="color:#3ad900;font-weight:400">&quot;Тип: &quot;</span> + fieldType.getName());<br />}<br /><br />Получение поля по имени:<br />Class c = obj.getClass();<br />Field nameField = c.getField(<span style="color:#3ad900;font-weight:400">&quot;name&quot;</span>);</pre></div></p><p></p><p>Методы getField() и getFields() возвращают только открытые (public) члены данных класса. Если требуется получить все поля некоторого класса нужно использовать методы getDeclaredField() и getDeclaredFields().</p><p></p><p><h3>Получение значения поля</h3></p><p><div class="codebox"><pre>Class c = obj.getClass(); <br />Field field = c.getDeclaredField(<span style="color:#3ad900;font-weight:400">&quot;name&quot;</span>);  <br />field.setAccessible(<span style="color:#ff0044;font-weight:400">true</span>);<br />String nameValue = (String) field.get(obj) ;<br />System.out.println(nameValue);<br /><br />Также у класса Field имеются специализированные <br />методы для получения значений примитивных типов: <br />getInt(), getFloat(), getByte() и др. <br />Для установки значения поля, используется метод set().<br />Class c = obj.getClass();<br />Field field = c.getDeclaredField(<span style="color:#3ad900;font-weight:400">&quot;name&quot;</span>); <br /><span style="color:#0088ff;font-weight:400">// field ничего не знает о самом объекте obj, </span><br />он знает всю информацию только о поле внутри объекта. <br />Т.е. сохранив поле можно устанавливать это поле <br />для разных экземпляров одного и того же класса<br />field.setAccessible(<span style="color:#ff0044;font-weight:400">true</span>); <span style="color:#0088ff;font-weight:400">// Разрешает изменять поле</span><br />field.set(obj, <span style="color:#3ad900;font-weight:400">&quot;New name&quot;</span>);  <br />String nameValue2 = (String) field.get(obj) ;<br />System.out.println(nameValue2);</pre></div></p><p><h3>Исследование конструкторов класса</h3></p><p><div class="codebox"><pre>Class c = obj.getClass(); <br />Constructor[] constructors = c.getConstructors(); <br /><span style="color:#ff9d00;font-weight:700">for</span> (Constructor constructor : constructors) { <br />    Class[] paramTypes = constructor.getParameterTypes(); <br />    <span style="color:#ff9d00;font-weight:700">for</span> (Class paramType : paramTypes) { <br />        System.out.print(paramType.getName() + <span style="color:#3ad900;font-weight:400">&quot; &quot;</span>); <br />    } <br />    System.out.println(); <br />}</pre></div></p><p><h3>Создание экземпляра</h3></p><p><div class="codebox"><pre>Class&lt;? <span style="color:#7f0044;font-weight:400">extends</span> Object&gt; colorClass = Color.<span style="color:#7f0044;font-weight:400">class</span>;<span style="color:#0088ff;font-weight:400">//получаем класс</span><br />Color c = (Color) colorClass<br />    .getConstructor(<span style="color:#7f0044;font-weight:400">byte</span>.<span style="color:#7f0044;font-weight:400">class</span>, <span style="color:#7f0044;font-weight:400">byte</span>.<span style="color:#7f0044;font-weight:400">class</span>)<br />    .newInstance((<span style="color:#7f0044;font-weight:400">byte</span>)<span style="color:#ff0044;font-weight:400">0</span>,(<span style="color:#7f0044;font-weight:400">byte</span>)<span style="color:#ff0044;font-weight:400">1</span>);</pre></div></p><p><h3>Динамический вызов метода</h3></p><p><div class="codebox"><pre>Class c = obj.getClass();<br />Class[] paramTypes = <span style="color:#ff9d00;font-weight:700">new</span> Class[] { String.<span style="color:#7f0044;font-weight:400">class</span>, <span style="color:#7f0044;font-weight:400">int</span>.<span style="color:#7f0044;font-weight:400">class</span> };<br /><span style="color:#0088ff;font-weight:400">//Method method = c.getMethod(&quot;getCalculateRating&quot;, String.class, int.class);</span><br />Method method = c.getMethod(<span style="color:#3ad900;font-weight:400">&quot;getCalculateRating&quot;</span>,  paramTypes);<br />Object[] args3 = <span style="color:#ff9d00;font-weight:700">new</span> Object[] { <span style="color:#ff9d00;font-weight:700">new</span> String(<span style="color:#3ad900;font-weight:400">&quot;First Calculate&quot;</span>), <span style="color:#ff9d00;font-weight:700">new</span> Integer(<span style="color:#ff0044;font-weight:400">10</span>) };<br />Double d = (Double) method.invoke(obj, args3);</pre></div></p><p></p><p>Получаем объект Method по имени метода getCalculateRating, вызываем метод invoke() объекта Method, и получаем результат работы метода. invoke принимает два параметра, первый - это объект, класс которого объявляет или наследует данный метод, а второй - массив значений параметров, которые передаются вызываемому методу.</p><p>Чтобы вызвать приватный метод, нужно вместо метода getMethod() вызвать getDeclaredMethod(), затем для получения доступа вызываем setAccessible(true).</p><p>Класс пакета java.lang.reflect Proxy - используется для того, чтобы создать обертку (Wrapper) над объектом и сделать проброс сквозной функциональности.</p><p></p><p></p></div>
</body>
</html>
