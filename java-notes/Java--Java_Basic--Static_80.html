<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Static</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Static</h1><br/><p></p><p><h2>Статические члены и модификатор static</h2></p><p><strong>Static</strong> — модификатор, применяемый к полю, блоку, методу или внутреннему классу. Данный модификатор указывает на привязку субъекта к текущему классу.</p><p></p><p><h3>Статические поля</h3></p><p>При создании объектов класса для каждого объекта создается своя копия нестатических обычных полей. А статические поля являются общими для всего класса. Поэтому они могут использоваться без создания объектов класса.</p><p>Например, создадим статическую переменную:</p><p>public class Program{</p><p>      </p><p>    public static void main(String[] args) {</p><p>         </p><p>        Person tom = new Person();</p><p>        Person bob = new Person();</p><p>         </p><p>        tom.displayId();    // Id = 1</p><p>        bob.displayId();    // Id = 2</p><p>        System.out.println(Person.counter); // 3</p><p>         </p><p>        // изменяем Person.counter</p><p>        Person.counter = 8;</p><p>         </p><p>        Person sam = new Person();</p><p>        sam.displayId();    // Id = 8</p><p>    }</p><p>}</p><p>class Person{</p><p>     </p><p>    private int id;</p><p>    static int counter=1;</p><p>     </p><p>    Person(){</p><p>        id = counter++;</p><p>    }</p><p>    public void displayId(){</p><p>     </p><p>        System.out.printf(&quot;Id: %d \n&quot;, id);</p><p>    }</p><p>}</p><p> </p><p>Класс Person содержит статическую переменную counter, которая увеличивается в конструкторе и ее значение присваивается переменной id. То есть при создании каждого нового объекта Person эта переменная будет увеличиваться, поэтому у каждого нового объекта Person значение поля id будет на 1 больше чем у предыдущего.</p><p>Так как переменная counter статическая, то мы можем обратиться к ней в программе по имени класса:</p><p><table class="table"><tr><th>нажми сюда</th><th>нажми сюда</th></tr><tr><td>  1</p><p>  2</p><p>  </td><td>  System.out.println(Person.counter);   // получаем значение</p><p>  Person.counter =   8;                   // изменяем значение</p><p>  </td></tr></table></p><p> </p><p></p><p><h3>Статические константы</h3></p><p>Также статическими бывают константы, которые являются общими для всего класса.</p><p><table class="table"><tr><th>нажми сюда</th><th>нажми сюда</th></tr><tr><td>  1</p><p>  2</p><p>  3</p><p>  4</p><p>  5</p><p>  6</p><p>  7</p><p>  8</p><p>  9</p><p>  10</p><p>  11</p><p>  12</p><p>  </td><td>  public class Program{</p><p>        </p><p>      public static void main(String[] args) {</p><p>           </p><p>          double radius = 60;</p><p>          System.out.printf(&quot;Radisu:   %f \n&quot;,   radius);               // 60</p><p>          System.out.printf(&quot;Area:   %f \n&quot;, Math.PI * radius);     // 188,4</p><p>      }</p><p>  }</p><p>  class Math{</p><p>      public static final double PI = 3.14;</p><p>  }</p><p>  </td></tr></table></p><p>Стоит отметить, что на протяжении всех предыдущих тем уже активно использовались статические константы. В частности, в выражении:</p><p><table class="table"><tr><th>нажми сюда</th><th>нажми сюда</th></tr><tr><td>  1</p><p>  </td><td>  System.out.println(&quot;hello&quot;);</p><p>  </td></tr></table></p><p><strong>out</strong> как раз представляет статическую константу класса System. Поэтому обращение к ней идет без создания объекта класса System.</p><p> </p><p><strong>Статические инициализаторы</strong></p><p>Статические инициализаторы предназначены для инициализации статических переменных, либо для выполнения таких действий, которые выполняются при создании самого первого объекта. Например, определим статический инициализатор:</p><p><table class="table"><tr><th>нажми сюда</th><th>нажми сюда</th></tr><tr><td>  1</p><p>  2</p><p>  3</p><p>  4</p><p>  5</p><p>  6</p><p>  7</p><p>  8</p><p>  9</p><p>  10</p><p>  11</p><p>  12</p><p>  13</p><p>  14</p><p>  15</p><p>  16</p><p>  17</p><p>  18</p><p>  19</p><p>  20</p><p>  21</p><p>  22</p><p>  23</p><p>  24</p><p>  25</p><p>  26</p><p>  27</p><p>  28</p><p>  29</p><p>  </td><td>  public class Program{</p><p>        </p><p>      public static void main(String[] args) {</p><p>           </p><p>          Person tom = new Person();</p><p>          Person bob = new Person();</p><p>           </p><p>          tom.displayId();      // Id = 105</p><p>          bob.displayId();      // Id = 106</p><p>      }</p><p>  }</p><p>  class Person{</p><p>       </p><p>      private int id;</p><p>      static int counter;</p><p>       </p><p>      static{</p><p>          counter = 105;</p><p>          System.out.println(&quot;Static   initializer&quot;);</p><p>      }</p><p>      Person(){</p><p>          id=counter++;</p><p>          System.out.println(&quot;Constructor&quot;);</p><p>      }</p><p>      public void displayId(){</p><p>       </p><p>          System.out.printf(&quot;Id:   %d \n&quot;, id);</p><p>      }</p><p>  }</p><p>  </td></tr></table></p><p>Статический инициализатор определяется как обычный, только перед ним ставится ключевое слово static. В данном случае в статическом инициализаторе мы устанавливаем начальное значение статического поля counter и выводим на консоль сообщение.</p><p>В самой программе создаются два объекта класса Person. Поэтому консольный вывод будет выглядеть следующим образом:</p><p>Static initializer</p><p>Constructor</p><p>Constructor</p><p>Id: 105</p><p>Id: 106</p><p>Стоит учитывать, что вызов статического инициализатора производится после загрузки класса и фактически до создания самого первого объекта класса.</p><p></p><p><h3>Статические методы</h3></p><p>Статические методы также относятся ко всему классу в целом. Например, в примере выше статическая переменная counter была доступна извне, и мы могли изменить ее значение вне класса Person. Сделаем ее недоступной для изменения извне, но доступной для чтения. Для этого используем статический метод:</p><p><table class="table"><tr><th>нажми сюда</th><th>нажми сюда</th></tr><tr><td>  1</p><p>  2</p><p>  3</p><p>  4</p><p>  5</p><p>  6</p><p>  7</p><p>  8</p><p>  9</p><p>  10</p><p>  11</p><p>  12</p><p>  13</p><p>  14</p><p>  15</p><p>  16</p><p>  17</p><p>  18</p><p>  19</p><p>  20</p><p>  21</p><p>  22</p><p>  23</p><p>  24</p><p>  25</p><p>  26</p><p>  27</p><p>  28</p><p>  29</p><p>  30</p><p>  </td><td>  public class Program{</p><p>        </p><p>      public static void main(String[] args) {</p><p>           </p><p>          Person.displayCounter();      // Counter: 1</p><p>           </p><p>          Person   tom = new Person();</p><p>          Person   bob = new Person();</p><p>           </p><p>          Person.displayCounter();      // Counter: 3</p><p>      }</p><p>  }</p><p>  class Person{</p><p>       </p><p>      private int id;</p><p>      private static int counter = 1;</p><p>       </p><p>      Person(){</p><p>          id   = counter++;</p><p>      }</p><p>      // статический метод</p><p>      public static void displayCounter(){</p><p>           </p><p>          System.out.printf(&quot;Counter:   %d \n&quot;, counter);</p><p>      }</p><p>      public void displayId(){</p><p>       </p><p>          System.out.printf(&quot;Id:   %d \n&quot;, id);</p><p>      }</p><p>  }</p><p>  </td></tr></table></p><p>Теперь статическая переменная недоступна извне, она приватная. А ее значение выводится с помощью статического метода displayCounter. Для обращения к статическому методу используется имя класса: <code>Person.displayCounter()</code>.</p><p>При использовании статических методов надо учитывать ограничения: в статических методах мы можем вызывать только другие статические методы и использовать только статические переменные.</p><p>Вообще методы определяются как статические, когда методы не затрагиют состояние объекта, то есть его нестатические поля и константы, и для вызова метода нет смысла создавать экземпляр класса. Например:</p><p><table class="table"><tr><th>нажми сюда</th><th>нажми сюда</th></tr><tr><td>  1</p><p>  2</p><p>  3</p><p>  4</p><p>  5</p><p>  6</p><p>  7</p><p>  8</p><p>  9</p><p>  10</p><p>  11</p><p>  12</p><p>  13</p><p>  14</p><p>  15</p><p>  16</p><p>  17</p><p>  18</p><p>  19</p><p>  20</p><p>  21</p><p>  </td><td>  public class Program{</p><p>        </p><p>      public static void main(String[] args) {</p><p>               </p><p>          System.out.println(Operation.sum(45,   23));          // 68</p><p>          System.out.println(Operation.subtract(45,   23));     // 22</p><p>          System.out.println(Operation.multiply(4,   23));      // 92</p><p>      }</p><p>  }</p><p>  class Operation{</p><p>       </p><p>      static int sum(int x, int y){</p><p>          return x + y;</p><p>      }</p><p>      static int subtract(int x, int y){</p><p>          return x - y;</p><p>      }</p><p>      static int multiply(int x, int y){</p><p>          return x * y;</p><p>      }</p><p>  }</p><p>  </td></tr></table></p><p>В данном случае для методов sum, subtract, multiply не имеет значения, какой именно экземпляр класса Operation используется. Эти методы работают только с параметрами, не затрагивая состояние класса. Поэтому их можно определить как статические.</p></div>
</body>
</html>
