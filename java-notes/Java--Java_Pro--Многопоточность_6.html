<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Многопоточность</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Многопоточность</h1><br/><p></p><p>Класс <strong>Thread</strong> - врепер над потоками операционной системы</p><p></p><p>Создать поток можно двумя способами:</p><p>• Отнаследоваться от класса <strong>Thread</strong> (класс, который отнаследуется от Thread, автоматически становится потоком) - этот способ может подойти тогда, когда не подходит стандартная реализация потока</p><p>• Реализовать интерфейс <strong>Runnable</strong> и передать реализующий класс конструктору класса Thread - этот способ предпочтительнее</p><p></p><p><div class="codebox"><pre><span style="color:#7f0044;font-weight:400">public</span> <span style="color:#7f0044;font-weight:400">class</span> MainHw20 {<br />    <span style="color:#7f0044;font-weight:400">public</span> <span style="color:#7f0044;font-weight:400">static</span> <span style="color:#7f0044;font-weight:400">void</span> main(String[] args) {<br />        System.out.println(<span style="color:#3ad900;font-weight:400">&quot;HW20&quot;</span>);<br />        SomeThing mThing = <span style="color:#ff9d00;font-weight:700">new</span> SomeThing(); <span style="color:#0088ff;font-weight:400">// mThing - объект класса, реализующего интерфейс Runnable</span><br />        Thread myThready = <span style="color:#ff9d00;font-weight:700">new</span> Thread(mThing); <span style="color:#0088ff;font-weight:400">// Создание потока</span><br />        myThready.start(); <span style="color:#0088ff;font-weight:400">// Запуск потока</span><br />        System.out.println(<span style="color:#3ad900;font-weight:400">&quot;Главный поток завершен&quot;</span>);<br />    }<br />}<br /><span style="color:#7f0044;font-weight:400">class</span> SomeThing <span style="color:#7f0044;font-weight:400">implements</span> Runnable{<br /><br />    @Override<br />    <span style="color:#7f0044;font-weight:400">public</span> <span style="color:#7f0044;font-weight:400">void</span> run() { <span style="color:#0088ff;font-weight:400">// Этот метод будет выполняться в побочном потоке</span><br />        <span style="color:#0088ff;font-weight:400">// run() предназначен, чтобы запускаться из других потоков</span><br />        System.out.println(<span style="color:#3ad900;font-weight:400">&quot;Побочный поток&quot;</span>);<br />    }<br />}<br /></pre></div></p><p></p><p>Если поток будет как демон, то когда основная программа закончится (основной поток закончится), демон продолжит работать, если у него еще есть работа.</p><p>Если поток будет не как демон, то когда основная программа закончится, она завершит работу и этого потока.</p><p></p><p>В Java есть средства для принудительного завершения потока:</p><p>●Thread.stop() - завершает поток незамедлительно после своего выполнения.</p><p>●Thread.suspend() - приостанавливает поток</p><p>●Thread.resume() - продолжает выполнение потока</p><p>Однако эти методы были объявлены устаревшими и их использование отныне <strong>крайне нежелательно</strong></p><p></p><p>Java имеет встроенный механизм оповещения потока, который называется <strong>Interruption:</strong></p><p><strong></strong></p><p>Главный поток (main):</p><p>mInc.<strong>interrupt()</strong>;  //Прерывание побочного потока из другого потока</p><p></p><p>Побочный поток:</p><p>if(!<strong>Thread.interrupted()</strong>) {//Проверка прерывания</p><p>                                    // Выполнение чего-то</p><p>   } else return; //Завершение потока</p><p>   </p><p><strong>Thread.sleep() </strong>— статический метод класса Thread, который приостанавливает выполнение потока, в котором он был вызван.</p><p>Во время выполнения метода sleep() система перестает выделять потоку процессорное время, распределяя его между другими потоками. </p><p>Метод sleep() может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет остановлен прерыванием (в этом случае он генерирует исключение InterruptedException).<strong></strong></p><p><strong></strong><span style="color:#000000;">●Thread.sleep(1500);   //Ждет полторы секунды</span></p><p><span style="color:#000000;">●Thread.sleep(2000, 100);    //Ждет 2 секунды и 100 наносекунд</span></p><p>Лучше использовать <strong>TimeUnit.SECONDS.sleep(1)</strong> вместо <strong>Thread.sleep(1000)</strong>;</p><p></p><p><strong>Thread.yield()</strong> - заставляет процессор переключиться на обработку других потоков системы.</p><p>//Ожидание поступления сообщения</p><p>while(!msgQueue.hasMessages())  { //Пока в очереди нет сообщений</p><p>  Thread.yield(); //Передать управление другим потокам</p><p>}</p><p></p><p><strong>Thread.join()</strong></p><p>В Java предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого. Для этого используется метод join().</p><p>Например, чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке. Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.</p><p></p><p><h2>Volatile переменные</h2></p><p>В целях повышения эффективности работы, спецификации языка Java позволяет JRE сохранять локальную копию переменной в каждом потоке, который ссылается на нее. Можно считать эти «внутри-потоковые» копии переменных похожими на кэш, помогающий избежать проверки главной памяти каждый раз, когда требуется доступ к значению переменной.</p><p>Но представьте, что произойдет в следующем случае: запустятся два потока, и первый прочитает переменную А как 5, тогда как второй – как 10. Если переменная А изменились от 5 до 10, то первый поток не будет знать об изменении, так что будет иметь неправильное значение А. Однако если переменная А будет помечена как volatile, то то в любое время, когда поток обращается к ее значению, он будет получать копию А и считывать ее текущее значение.</p><p>Если переменные в вашем приложении не меняются, то внутри-потоковый кэш имеет смысл. В противном случае, очень полезно знать, что может сделать для вас ключевое слово volatile.</p><p><strong>volatile</strong> - работает для <strong>примитивных</strong> типов. Используется, если нужно использовать эти данные из разных потоков. Не гаранирует, что изменения будут проходить атомарно. Гарантирует, что все потоки увидят изменения. А то, что данные не будут сломаны, не гарантирует. С int и long лучше не использовать.</p><p>private volatile boolean mIsIncrement = true; // <strong><span style="color:#333333;"></span></strong></p><p><strong><span style="color:#333333;"> </span></strong><strong></strong></p><p><strong>sinchronized(program_1.class) {</strong> // позволяет заходить в критическую секцию только одному потоку (синхронизация по объекту program_1)</p><p>                                                        // (this) для нестатического объекта</p><p>                        // критическая секция</p><p><strong>}</strong></p><p><strong></strong></p><p><strong> private static synchronized void sout(String name){ //так как метод статический, синхронизируется по объекту, в котором этот метод находится</strong></p><p><strong> </strong></p><p><strong>}</strong></p><p><strong></strong>Критическую секцию желательно делать как можно меньше<strong></strong></p><p><strong></strong></p><p><strong></strong>Синхронизация по публичному объекту - плохо, так как где-то в другом месте кто-то может синхронизироваться по этому же объекту, и во время работы его кода ни один поток не зайдет в нашу критическую секцию. Поэтому лучше сделать отдельный объект для синхронизации:</p><p></p><p><strong>private static final Object lock = new Object();</strong> // для нестатического объекта <strong>Object lock</strong> может быть и статическим и нестатическим</p><p>// ....</p><p><strong>sinchronized(lock) {</strong></p><p>                        // критическая секция</p><p><strong>}</strong></p><p><strong></strong></p><p><strong></strong>Нужно избегать взаимную блокировку потоков:<strong></strong></p><p><strong>Object a = new Object();</strong></p><p><strong>Object b = new Object();</strong></p><p><strong></strong></p><p><strong>synchronized (a) {</strong></p><p><strong>    b.wait();                   //  </strong>wait() - ожидание блокировки на объекте, этот метод блокирующий. Выйдем из этого метода тогда, когда блокировка с потока будет снята<strong></strong></p><p><strong>    synchronized (b){</strong></p><p><strong>        a.wait()</strong></p><p><strong>    }</strong></p><p><strong>}</strong></p><p><strong></strong></p><p><strong></strong>Пулл потоков - заранее создается набор потоков и потом они используются. Рекомендуется создавать в 2-3 раза больше потоков, чем есть ядер. Кол-во ядер:</p><p><strong>private static int DEFAULT_THREAD_COUNT = Runtime.getRuntime().availableProcessors();</strong></p><p><strong></strong></p><p><strong> </strong><div class="codebox"><pre><span style="color:#7f0044;font-weight:400">public</span> <span style="color:#7f0044;font-weight:400">class</span> ThreadPoolUtil {<br />    <span style="color:#7f0044;font-weight:400">private</span> <span style="color:#7f0044;font-weight:400">static</span> <span style="color:#7f0044;font-weight:400">final</span> <span style="color:#7f0044;font-weight:400">int</span> DEFAULT_THREAD_COUNT = Runtime.getRuntime().availableProcessors() * <span style="color:#ff0044;font-weight:400">3</span>;<br />    <span style="color:#7f0044;font-weight:400">private</span> <span style="color:#7f0044;font-weight:400">final</span> List&lt;Thread&gt; threadList = <span style="color:#ff9d00;font-weight:700">new</span> ArrayList&lt;&gt;();<br />    <span style="color:#7f0044;font-weight:400">private</span> <span style="color:#7f0044;font-weight:400">final</span> Queue&lt;Runnable&gt; runnableQueue = <span style="color:#ff9d00;font-weight:700">new</span> LinkedList&lt;&gt;();<br /><br />    <span style="color:#7f0044;font-weight:400">public</span> ThreadPoolUtil() {<br />        <span style="color:#ff9d00;font-weight:700">this</span>(DEFAULT_THREAD_COUNT);<br />    }<br /><br />    <span style="color:#7f0044;font-weight:400">public</span> ThreadPoolUtil(<span style="color:#7f0044;font-weight:400">int</span> threadCount) {<br />        <span style="color:#ff9d00;font-weight:700">for</span> (<span style="color:#7f0044;font-weight:400">int</span> i = <span style="color:#ff0044;font-weight:400">0</span>; i &lt; threadCount; i++) {<br />            <span style="color:#7f0044;font-weight:400">final</span> Thread thread = <span style="color:#ff9d00;font-weight:700">new</span> Thread(() -&gt; {<br />                <span style="color:#ff9d00;font-weight:700">while</span> (!Thread.interrupted()) {<br />                    <span style="color:#ff9d00;font-weight:700">if</span> (runnableQueue.isEmpty()) {<br />                        Thread.yield();<br />                    } <span style="color:#ff9d00;font-weight:700">else</span> {<br />                        runnableQueue.poll().run();<br />                    }<br />                }<br />            });<br />            thread.setName(<span style="color:#3ad900;font-weight:400">&quot;ThreadPoolUtil-&quot;</span> + i);<br />            threadList.add(thread);<br />        }<br />        <span style="color:#ff9d00;font-weight:700">for</span> (Thread thread : threadList) {<br />            thread.start();<br />        }<br />    }<br /><br />    <span style="color:#7f0044;font-weight:400">public</span> <span style="color:#7f0044;font-weight:400">void</span> stop(){<br />        <span style="color:#ff9d00;font-weight:700">for</span> (Thread thread : threadList) {<br />            thread.interrupt();<br />        }<br />    }<br /><br />    <span style="color:#7f0044;font-weight:400">public</span> <span style="color:#7f0044;font-weight:400">void</span> run(Runnable runnable) {<br />        runnableQueue.add(runnable);<br />    }<br />}</pre></div></p><p><div class="codebox"><pre><span style="color:#7f0044;font-weight:400">public</span> <span style="color:#7f0044;font-weight:400">class</span> MainHw20 {<br />    <span style="color:#7f0044;font-weight:400">public</span> <span style="color:#7f0044;font-weight:400">static</span> <span style="color:#7f0044;font-weight:400">void</span> main(String[] args) {<br />        <span style="color:#7f0044;font-weight:400">final</span> ThreadPoolUtil threadPool = <span style="color:#ff9d00;font-weight:700">new</span> ThreadPoolUtil();<br />        threadPool.run(() -&gt; {<br />            <span style="color:#0088ff;font-weight:400">//to do something</span><br />        });<br /><br /><br />        <span style="color:#ff9d00;font-weight:700">try</span> {<br />            TimeUnit.SECONDS.sleep(<span style="color:#ff0044;font-weight:400">5</span>);<br />            Thread.sleep(<span style="color:#ff0044;font-weight:400">1000</span>);<br />            threadPool.stop();<br />        } <span style="color:#ff9d00;font-weight:700">catch</span> (InterruptedException e) {<br />            e.printStackTrace();<br />        }<br />    }<br />}</pre></div></p><p> </p><p> Если на классе написано Threadsafe - значит класс потокобезопасный.<strong></strong></p><p><strong> </strong></p><p><strong> ---------------------------------------------------------------------------------------</strong></p><p><strong> </strong></p><p><strong></strong><strong><span style="color:#cc7832;">private final </span></strong><strong>Lock </strong><strong><span style="color:#9876aa;">lock </span></strong><strong>= </strong><strong><span style="color:#cc7832;">new </span></strong><strong>ReentrantLock()</strong><strong><span style="color:#cc7832;">;</span></strong><strong> - </strong>усовершенствованная (по сравнению с sinchronized) блокировка потоков<strong></strong></p><p><strong></strong><strong><span style="color:#cc7832;">private final </span></strong><strong>Lock </strong><strong><span style="color:#9876aa;">lock </span></strong><strong>= </strong><strong><span style="color:#cc7832;">new </span></strong><strong>ReentrantLock(</strong><strong><span style="color:#cc7832;">true</span></strong><strong>)</strong><strong><span style="color:#cc7832;">;</span></strong><strong> - </strong>fair=true - блокировка будет справедливой, т.е. если на эту блокировку пришел поток 2, а потом поток 3, и оба ждут, то когда блокировка освободится, следующим пойдет тот, кто пришел раньше. Это добавит дополнительные инструкции. Передавать сюда true нужно крайне осторожно.<strong></strong></p><p><strong></strong><strong><span style="color:#cc7832;">private final </span></strong><strong>Lock </strong><strong><span style="color:#9876aa;">lock </span></strong><strong>= </strong><strong><span style="color:#cc7832;">new </span></strong><strong>ReentrantLock(</strong><strong><span style="color:#cc7832;">false</span></strong><strong>)</strong><strong><span style="color:#cc7832;">;</span></strong><strong> - </strong>( либо не указывать fair=<span style="color:#cc7832;">false</span>: ReentrantLock() ) - потоки выполняться в другой очередности<strong></strong></p><p><strong> </strong></p><p><strong></strong><strong><span style="color:#9876aa;">lock</span></strong><strong>.lock()</strong><strong><span style="color:#cc7832;">; </span></strong>- вызвать блокировку</p><p>// ........</p><p><strong><span style="color:#9876aa;">lock</span></strong><strong>.unlock()</strong><strong><span style="color:#cc7832;">;</span></strong><span style="color:#cc7832;"> </span>- освободить блокировку<strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;">while </span></strong><strong>(!</strong><strong><span style="color:#9876aa;">lock</span></strong><strong>.tryLock()){</strong></p><p><strong>    // .....</strong></p><p><strong>}</strong></p><p><strong> </strong></p><p><strong> </strong>Это более гибкий способ (<strong>sinchronized</strong> нельзя прервать), <strong>ReentrantLock</strong> прервать можно.<strong></strong></p><p><strong> </strong>Метод блокировки применяется &quot;Compare And Set&quot; (Сохраняется версия предыдущего состояния).</p><p> Эту блокировку нужно использовать в try с ресурсами:</p><p> <strong></strong></p><p><strong> </strong><strong><span style="color:#cc7832;">try </span></strong><strong>{</strong></p><p><strong>    </strong><strong><span style="color:#9876aa;">lock</span></strong><strong>.lock()</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;">           </span></strong> // - критическая секция<strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;"></span></strong><strong>} </strong><strong><span style="color:#cc7832;">finally </span></strong><strong>{</strong></p><p><strong>    </strong><strong><span style="color:#9876aa;">lock</span></strong><strong>.unlock()</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;"></span></strong><strong>}</strong></p><p><strong> </strong></p><p><strong>  ---------------------------------------------------------------------------------------</strong></p><p><strong>  </strong></p><p><strong> </strong><strong><span style="color:#cc7832;">private final </span></strong><strong>ReadWriteLock </strong><strong><span style="color:#9876aa;">readWriteLock </span></strong><strong>= </strong><strong><span style="color:#cc7832;">new </span></strong><strong>ReentrantReadWriteLock()</strong><strong><span style="color:#cc7832;">;</span></strong><strong></strong></p><p><strong> </strong></p><p><strong> </strong><strong><span style="color:#cc7832;">final </span></strong><strong>Lock lock = </strong><strong><span style="color:#9876aa;">readWriteLock</span></strong><strong>.writeLock()</strong><strong><span style="color:#cc7832;">; </span></strong>- запрет на чтение и запись другими потоками пока не освободим блокировку; запись не начнется пока не закончится чтение другими потоками<strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;">try </span></strong><strong>{</strong></p><p><strong>    lock.lock()</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;">        // Запись</span></strong></p><p><strong><span style="color:#cc7832;"></span></strong><strong>} </strong><strong><span style="color:#cc7832;">finally </span></strong><strong>{</strong></p><p><strong>    lock.unlock()</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;"></span></strong><strong>}</strong></p><p><strong> </strong></p><p><strong> </strong><strong><span style="color:#cc7832;">final </span></strong><strong>Lock lock = </strong><strong><span style="color:#9876aa;">readWriteLock</span></strong><strong>.readLock()</strong><strong><span style="color:#cc7832;">; </span></strong>- если смогли захватить эту блокировку, значит никто не записывает эту сущность. После того, как мы освободим блокировку, другой поток сможет сделать изменения этой сущности. Таким образом сохраняется консистентность данных.<strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;">try </span></strong><strong>{</strong></p><p><strong>    lock.lock()</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;">        // Чтение</span></strong></p><p><strong><span style="color:#cc7832;"></span></strong><strong>} </strong><strong><span style="color:#cc7832;">finally </span></strong><strong>{</strong></p><p><strong>    lock.unlock()</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;"></span></strong><strong>}</strong></p><p><strong> </strong></p><p><strong> --------------------------------------------------------------------------------------- </strong></p><p><strong> </strong></p><p><strong></strong> Сохранение контекста потоков</p><p><strong> </strong></p><p><strong> ThreadLocal&lt;Object&gt; objectThreadLocal = </strong><strong><span style="color:#cc7832;">new </span></strong><strong>ThreadLocal&lt;&gt;()</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;"></span></strong><strong>objectThreadLocal.set(object)</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;"></span></strong><strong>objectThreadLocal.get()</strong><strong><span style="color:#cc7832;">;</span></strong> - чтение будет произведено относительно того же потока, в котором производился<strong> set</strong></p><p><strong> </strong></p><p><strong>  ---------------------------------------------------------------------------------------</strong></p><p><strong> </strong></p><p><strong> Object o = </strong><strong><span style="color:#cc7832;">new </span></strong><strong>Object()</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;">for </span></strong><strong>(</strong><strong><span style="color:#cc7832;">int </span></strong><strong>i = </strong><strong><span style="color:#6897bb;">0</span></strong><strong><span style="color:#cc7832;">; </span></strong><strong>i &lt; </strong><strong><span style="color:#6897bb;">100</span></strong><strong><span style="color:#cc7832;">; </span></strong><strong>i++) {</strong></p><p><strong>    </strong><strong><span style="color:#cc7832;">new </span></strong><strong>Thread(() -&gt; {</strong></p><p><strong>        </strong><strong><span style="color:#cc7832;">synchronized </span></strong><strong>(</strong><strong><span style="color:#b389c5;">o</span></strong><strong>) { </strong>// Поток 1 захватывает блокировку<strong></strong></p><p><strong>            </strong><strong><span style="color:#cc7832;">try </span></strong><strong>{</strong></p><p><strong>                </strong><strong><span style="color:#b389c5;">o</span></strong><strong>.wait()</strong><strong><span style="color:#cc7832;">;  </span></strong>// Поток 1 вешается на ожидание (Состояние WAITING), при этом блокировка по объекту <strong>o </strong>снимается<strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;">            </span></strong><strong>} </strong><strong><span style="color:#cc7832;">catch </span></strong><strong>(InterruptedException e) {</strong></p><p><strong>                e.printStackTrace()</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;">            </span></strong><strong>}</strong></p><p><strong>        }</strong></p><p><strong>    }).start()</strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;"></span></strong><strong>}</strong></p><p><strong></strong></p><p><strong></strong><strong><span style="color:#cc7832;">new </span></strong><strong>Thread(() -&gt; {</strong></p><p><strong>    </strong><strong><span style="color:#cc7832;">synchronized </span></strong><strong>(</strong><strong><span style="color:#b389c5;">o</span></strong><strong>){ </strong>// Поток 2 приходит и не может захватить блокировку, т.к. ее захватил Поток 1<strong></strong></p><p><strong>        </strong><strong><span style="color:#b389c5;">o</span></strong><strong>.notify()</strong><strong><span style="color:#cc7832;">; </span></strong>// После того, как Поток 1 переходит в сотосяние WAITING, Поток 2 заходит в блок критической секции, захватывает блокировку, и вызывает <strong>notify()</strong></p><p><strong>                        </strong>//<strong> notify() </strong>“Уведомить” говорит, что нужно освободить блокировку на этом объекте<strong> o </strong>для первого попавшегося потока</p><p>                        <strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;">        </span></strong><strong><span style="color:#b389c5;">o</span></strong><strong>.notifyAll()</strong><strong><span style="color:#cc7832;">; </span></strong>// “Уведомить всех” Все потоки перейдут из состояния WAITING в состояние RUNNABLE и потом в состояние BLOCKED, но блокировка с потоков не снимется, т.к. блокировка захвачена Потоком 2. Потоки смогут продолжить работу после выхода Потока 2 из критической секции<strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;">    </span></strong><strong>}</strong></p><p><strong>})</strong><strong><span style="color:#cc7832;">;</span></strong><strong></strong></p><p><strong> </strong></p><p><strong>   ---------------------------------------------------------------------------------------</strong></p><p><strong>   </strong></p><p><strong>Callable</strong> - интерфейс, который возвращает какое-то значение (есть метод call() ). Этот интерфейс создан для многопоточности так же как и Runnable. Отличием от Runnable является то, что Callable возвращает какой-то результат.</p><p></p><p><strong>Callable&lt;String&gt; c = </strong><strong><span style="color:#cc7832;">new </span></strong><strong>Callable&lt;String&gt;() {</strong></p><p><strong>    </strong><strong><span style="color:#bbb529;">@Override</span></strong></p><p><strong><span style="color:#bbb529;">    </span></strong><strong><span style="color:#cc7832;">public </span></strong><strong>String </strong><strong><span style="color:#003992;">call</span></strong><strong>() </strong><strong><span style="color:#cc7832;">throws </span></strong><strong>Exception {</strong></p><p><strong>        </strong><strong><span style="color:#808080;">// To do something</span></strong></p><p><strong><span style="color:#808080;">        </span></strong><strong><span style="color:#cc7832;">return </span></strong><strong><span style="color:#6a8759;">&quot;Success&quot;</span></strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;">    </span></strong><strong>}</strong></p><p><strong>}</strong><strong><span style="color:#cc7832;">;</span></strong><strong></strong></p><p><strong>Future&lt;String&gt; submit = exetutorService.submit(c)</strong><strong><span style="color:#cc7832;">;</span></strong><strong></strong></p><p><strong> </strong></p><p><strong> </strong></p><p><strong> </strong></p><p><strong></strong> ---------------------------------------------------------------------------------------</p><p> </p></div>
</body>
</html>
