<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Microservices</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Microservices</h1><br/><p>JMS &amp; Microservices</p><p></p><p>Microservices (Микросервисы - архитектурный подход) - разные приложения, обычно размещенные на разных компьютерах (хостах). Если у компьютера хватает вычислительных ресурсов, микросервисы могут быть размещены на одном компьютере. Микросервисы - это отдельные приложения. Если использовать TomCat, то это можут быть каждый микросервис как отдельно задеплоиный war-файл в TomCat-е.</p><p>Если это Spring Boot , то это отдельно запущенный jar-файл. И каждый jar-файл считается микросервисом.</p><p>Микросервис - это какой-то функционал (либо что-то считает; либо какие-то данные достает, провайдит; либо выполняет функционал в виде прокси или чего-то еще).</p><p></p><p>Network protocols (http (tcp/ip), socket, JMS, file, database, WebSocket)  </p><p>socket - прямое соединение</p><p>JMS - Java message service (Kafka, Redis, RebitMQ) -&gt; Message Queue (обмен сообщениями)</p><p>WebSocket - соединение, когда сервер может клиенту отправить что-то, если клиент подписался на это событие</p><p>tcp = host (ip address) + port</p><p>Если несколько микросервисов коннектятся к одной базе данных - нарушение микросервисной архитектуры. Как правило выделяют отдельную базу для каждого микросервиса.</p><p>Microservice: Java file (JAR, WAR) + config </p><p></p><p>JMS</p><p>- консюмеры - потребляют сообщения</p><p>- продюсеры - производят сообщения</p><p>- сабскрайбер</p><p>- провайдер</p><p>Кто-то генерит данные, а кто-то от этих данных зависит. Мы не знаем когда эти данные придут, и нам нужна одна точка входа где эти данные будут храниться и куда эти данные будут отправляться. Данные, которые часто меняются, не сильно годиться хранить в простых базах данных.</p><p></p><p>Spring Cloud (server of configurations) - один из вариантов использования: добывляет возможность не грузить каждому отдельно статичесие конфиги по работе других сервисов, а иметь отдельное место где все эти конфиги лежат (каждый сервер коннектится к серверу конфигов)</p><p></p><p>Properties (свойства) микросервисов (должны быть у каждого микросервиса):</p><p>1. Discovery -&gt; Service Discovery (сервис нужно как-то найти и определить чтоб другие знали где он лежит). Достигается с помощью Service Discovery - есть у Spring Cloud функция (размещаем конфиг, сюда коннектятся другие сервисы, получают где наш сервис расположен)</p><p>2. Fault tolarance -&gt; Circuit Breaker (как правило все микросервисы должны быть “Fault tolarance” - когда один упал, должен быть второй, третий, четвертый сервис, котрый дублирует его функционал; как правило поддерживают горизонтальную масштабируемость). Circuit Breaker - когда прокси или не лоадбалансер другое приложение которое следит за микросервсиной архитектурой знает выключилось или не выключилось.</p><p>3. Resilience -&gt; Load Balancing (разделение (разнесение приложения) по датацентрам; как правило разносят регионально). Load Balancing - больше управляет по регионам.</p><p>4. Configuration -&gt; Configuration (админ должен запустить сервис с разным конфигом, как-то настроить, чтобы не перекомпиливать проект). Делается грамотный менеджмент конфигураций (решают ДевОпсы)</p><p>5. API management -&gt; API gateway (чтобы обслуживать приложение, слкдить за его состоянием (Health - все ли хорошо с производительностью, отзывчивостью). С помощью API gateway контролируем состояние наших приложений (мини агрегатор или главный сервер). У каждого приложения есть API для его управления и есть единая точка входа или другое приложение, которое следит за работой.</p><p></p><p>Patterns:</p><p>1. Aggregator - есть много микросервисов, единая точка входа (Load Balancer), Agregator (бизнес логика) принимает запрос и полностью сам коннектится в нужный сервис и сам отдает ответ (Aggregator - главный сервис; Srvice A, Srvice B, Service C - микросервисы)</p><p>2. Agent - Proxy ничего не обрабатывает, просто перенапрявляет запросы</p><p>3. Chain - цепочка микросервисов - чем-то похоже на агрегатор, но сложнее. Все запросы идут на один микросервис, если у него нет какого-то функционала, он коннектится к другому микросервису и т. д.</p><p>4. Branch - несколько цепочек</p><p>5. Data sharing - коннект может быть напрямую, не через главный сервис</p><p>6. Asynchronous messaging - асинхронный обмен сообщениями. Запрос идет на один сервис C, но этот сервис не может напрямую получить данные, он обращается в очередь сообщений Queue - “Я хочу вычислить то-то, дайте ответ” и подписывается в топик на ответ. Через Message Queue другие сервисы отправляют ответы на сервис C.</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p></div>
</body>
</html>
