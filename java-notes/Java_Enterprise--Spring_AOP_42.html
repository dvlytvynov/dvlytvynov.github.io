<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Spring AOP</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Spring AOP</h1><br/><p>Spring AOP - аспекты Spring</p><p></p><p>Можно добавить кроссфункционал:</p><p>- <strong>logging</strong></p><p>- <strong>profiling</strong> - профилирование - измеряется время выполнение того или иного метода (нужно понять, подходит такая производительность или нет)</p><p>- <strong>security</strong></p><p></p><p>При вызове любого метода может отработать <strong>Join point</strong>. Он перехватит вызов этого метода, и можно нам добавить туда какой-то функционал (<strong>logging</strong>, <strong>profiling</strong>, <strong>security</strong>).</p><p><strong>Join point</strong> - это где мы перехватываем</p><p><strong>Pointcut</strong> - это что мы будем выполнять (т.е. какой метод) после того как перехватили</p><p><strong>Advice</strong> - типы перехвата (при каких условиях будем выполнять <strong>Pointcut</strong>):</p><p>    - <strong>Before</strong> - <strong>Pointcut</strong> выполнится перед</p><p>    - <strong>After</strong></p><p>    - <strong>After returning</strong></p><p>    - <strong>After throwing</strong></p><p>    - <strong>After finally</strong></p><p>    - <strong>Around</strong></p><p></p><p>---------------------- Привязываемся к отдельным методам:</p><p>==== AspectLogging.java ====</p><p>@Aspect</p><p>@Component</p><p>public class AspectLogging {</p><p>    private final Logger log = LoggerFactory.getLogger(AspectLogging.class);</p><p></p><p>    @Pointcut(&quot;execution(public * hillel.course.web.GetNameController.*(..))&quot;) // Join point = &quot;execution(public * hillel.course.web.GetNameController.*(..))&quot; - подсоединяемся на все публичные методы класса hillel.course.web.GetNameController и выполняем функцию callAtSomeController().</p><p>    public void callAtSomeController() { }</p><p></p><p>    @Before(&quot;callAtSomeController()&quot;)</p><p>    public void beforeCallAtMethod(JoinPoint jp) { // JoinPoint jp - вызов метода</p><p>        String args = Arrays.stream(jp.getArgs())</p><p>                .map(Object::toString)</p><p>                .collect(Collectors.joining(&quot;,&quot;));</p><p>        log.debug(&quot;before &quot; + jp + &quot;, args=[&quot; + args + &quot;]&quot;);</p><p>    }</p><p></p><p>    @After(&quot;callAtSomeController()&quot;)</p><p>    public void afterCallAtMethod(JoinPoint jp) {</p><p>        log.debug(&quot;after &quot; + jp.toString());</p><p>    }</p><p>}</p><p></p><p>---------------------- Привязываемся к аннотации:</p><p>==== OurLogging.java ====</p><p>@Retention(RetentionPolicy.RUNTIME)</p><p>@Target(ElementType.METHOD)</p><p>public @interface OurLogging { // Объявляем аннотацию</p><p>}    </p><p></p><p>==== AspectLoggingForPostMapping.java ====</p><p>@Aspect</p><p>@Component</p><p>public class AspectLoggingForPostMapping {</p><p>    private final Logger log = LoggerFactory.getLogger(AspectLoggingForPostMapping.class);</p><p></p><p>    @Pointcut(&quot;@annotation(OurLogging)&quot;) // Этой аннотацией нужно пометить тот метод, который хотим перехватить</p><p>    public void callAtSomeController() { }</p><p></p><p>    @Before(&quot;callAtSomeController()&quot;)</p><p>    public void beforeCallAtMethod(JoinPoint jp) {</p><p>        String args = Arrays.stream(jp.getArgs())</p><p>                .map(Object::toString)</p><p>                .collect(Collectors.joining(&quot;,&quot;));</p><p>        log.debug(&quot;before &quot; + jp + &quot;, args=[&quot; + args + &quot;]&quot;);</p><p>    }</p><p></p><p>    @After(&quot;callAtSomeController()&quot;)</p><p>    public void afterCallAtMethod(JoinPoint jp) {</p><p>        log.debug(&quot;after &quot; + jp.toString());</p><p>    }</p><p>} </p><p></p><p>---------------------- Привязываемся к аннотации секьюрности:</p><p>==== OurSecurityFilterForName.java ====</p><p>@Retention(RetentionPolicy.RUNTIME)</p><p>@Target(ElementType.METHOD)</p><p>public @interface OurSecurityFilterForName {</p><p>}     </p><p></p><p>==== AspectSecurityForName.java ====</p><p>@Aspect</p><p>@Component</p><p>public class AspectSecurityForName {</p><p>    private final Logger log = LoggerFactory.getLogger(AspectSecurityForName.class);</p><p></p><p>    @Pointcut(&quot;@annotation(OurSecurityFilterForName) &amp;&amp; args(name, ..)&quot;) // Этой аннотацией нужно пеметить метод, который хотим перехватить. В примере метод, который принимает GET запрос с параметром name (метод помечен @GetMapping, класс помечен @Controller).</p><p>    public void callCheckForParameter(String name) { }</p><p></p><p>    @Around(&quot;callCheckForParameter(name)&quot;)</p><p>    public Object aroundCallAtMethod(ProceedingJoinPoint jp, String name) throws Throwable { // Значение name заменяется на “****” если совпадает с “ffff” (можно использовать как фильтр - защита от неприемлемого содержания)</p><p>        Object[] args = jp.getArgs();</p><p>        if (args != null &amp;&amp; name != null) {</p><p>            if (&quot;ffff&quot;.equals(name)) {</p><p>                log.warn(&quot;name = &quot; + name);</p><p></p><p>                //change the argument &quot;name&quot;</p><p>                for (int i = 0; i &lt; args.length; i++) {</p><p>                    if (&quot;ffff&quot;.equals(args[i])) {</p><p>                        args[i] = &quot;****&quot;;</p><p>                        break;</p><p>                    }</p><p>                }</p><p>            }</p><p>        }</p><p>        return jp.proceed(args);</p><p>    }</p><p>}</p><p></p><p>---------------------- Профилирование:</p><p>==== AspectProfiling.java ====</p><p>@Aspect</p><p>@Component</p><p>public class AspectProfiling {</p><p>    private final Logger log = LoggerFactory.getLogger(AspectProfiling.class);</p><p></p><p>    @Pointcut(&quot;execution(public * hillel.course.web.*.*(..))&quot;) // На все публичные методы во всех классах в пакете hillel.course.web</p><p>    public void callOurProfiling() { }</p><p></p><p>    @Around(&quot;callOurProfiling()&quot;)</p><p>    public Object aroundCall(ProceedingJoinPoint jp) throws Throwable { // Вызывает что-то на Join point, засекает время; заканчивается время, выводится инфо в лог</p><p>        StopWatch clock = new StopWatch(jp.toString());</p><p>        try {</p><p>            clock.start(jp.toShortString());</p><p>            return jp.proceed(jp.getArgs());</p><p>        } finally {</p><p>            clock.stop();</p><p>//            log.info(clock.prettyPrint());</p><p>            log.debug(&quot;ms = &quot; + clock.getLastTaskTimeNanos() / 1000000.0);</p><p>        }</p><p>    }</p><p>} </p><p></p><p></p><p></p><p></p></div>
</body>
</html>
