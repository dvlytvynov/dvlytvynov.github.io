<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Concurrent</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Concurrent</h1><br/><p></p><p><h2>java.util.concurrent.*</h2></p><p></p><p>• Concurrent Collections - хранение наборов элементов безопасно в многопоточной среде</p><p>• Queues - безопасные очереди</p><p>• Synchronizers - механизмы, позволяющие более сложно закрутить выполнение разных потоков без низкоуровневых блоков синхронизации. Синхронизаторы – вспомогательные утилиты для синхронизации потоков, которые дают возможность разработчику регулировать и/или ограничивать работу потоков и предоставляют более высокий уровень абстракции, чем основные примитивы языка (мониторы).<strong></strong></p><p><strong></strong>   ◇ Semaphore - Разрешает находится в критической секции только определенному числу потоков</p><p>   ◇ CountDownLatch (замок с обратным отсчетом) - Блокирует критическую секцию, пока не сработают все условия (уменьшится значение счетчика до 0)</p><p>   ◇ CyclicBarrier</p><p>   ◇ Exchanger&lt;V&gt;</p><p>   ◇ Phaser</p><p>• Executors - здесь находятся преконфигурированные потокобезопасные пуллы потоков с очередями</p><p>     <div class="codebox"><pre>    <span style="color:#7f0044;font-weight:400">private</span> <span style="color:#7f0044;font-weight:400">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span style="color:#ff0044;font-weight:400">10</span>);<br />    .........<br />    executorService.submit( () -&gt; {<br />    <span style="color:#0088ff;font-weight:400">// To do something</span><br />    });<br /></pre></div></p><p>   ◇ Метод submit() возвращает Future - некоторый объект (враппер), который будет содержать наш результат. На момент вызова метода submit() результата еще нет, результат будет известен в будущем, поэтому “future”:</p><p>   ◇ Future&lt;String&gt; submit = executorService.submit( с );</p><p>   ◇ <div class="codebox"><pre>Callable&lt;String&gt; c = <span style="color:#ff9d00;font-weight:700">new</span> Callable&lt;String&gt;() {<br />    @Override<br />    <span style="color:#7f0044;font-weight:400">public</span> String call() <span style="color:#7f0044;font-weight:400">throws</span> Exception {<br />        <span style="color:#0088ff;font-weight:400">// To do something</span><br />        <span style="color:#ff9d00;font-weight:700">return</span> <span style="color:#3ad900;font-weight:400">&quot;Success&quot;</span>;<br />    }<br />};<br />Future&lt;String&gt; submit = exetutorService.submit(c);</pre></div></p><p>   ◇ submit.get(); - как только этот метод вызовем, текущий поток будет заблокирован до тех пор, пока не отработает в отдельном потоке, то что мы запросили в объекте Callable&lt;String&gt; c </p><p>   ◇ submit.isDone(); - проверить готово или не готово</p><p>   ◇ <div class="codebox"><pre><span style="color:#7f0044;font-weight:400">private</span> <span style="color:#7f0044;font-weight:400">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span style="color:#ff0044;font-weight:400">10</span>);<br />.......<br /><br />        CompletableFuture.supplyAsync(()-&gt;{ <br />        <span style="color:#0088ff;font-weight:400">// эта лямбда уже будет работать в отдельном потоке,</span><br />        <span style="color:#0088ff;font-weight:400">// который возьмется из пулла по умолчанию и правильно </span><br />        <span style="color:#0088ff;font-weight:400">// сконфигурирован</span><br />            <span style="color:#0088ff;font-weight:400">// To do something</span><br />            <span style="color:#ff9d00;font-weight:700">return</span> <span style="color:#3ad900;font-weight:400">&quot;Success&quot;</span>;<br />        }); <br /><br />        <br />        CompletableFuture.supplyAsync(()-&gt;{<br />            <span style="color:#0088ff;font-weight:400">// To do something</span><br />            <span style="color:#ff9d00;font-weight:700">return</span> <span style="color:#3ad900;font-weight:400">&quot;Success&quot;</span>;<br />        }, executorService); <br />        <span style="color:#0088ff;font-weight:400">// Если передать свой ExecutorService, </span><br />        <span style="color:#0088ff;font-weight:400">// то эта лямбда будет выполняться</span><br />        <span style="color:#0088ff;font-weight:400">// на потоке нашего пулла потоков</span></pre></div></p><p>• Locks</p><p>• Atomics - механизмы, позволяющие изменять примитивные типы, избегая ключевого слова volatile. Т.е. атомарно без проблем с утечкой через кэш и без проблем с частичным изменением</p><p>   ◇ В дочернем пакете java.util.concurrent.atomic находится набор классов для атомарной работы с примитивными типами.</p><p>   ◇ Контракт данных классов гарантирует выполнение операции compare-and-set за «1 единицу процессорного времени». При установке нового значения этой переменной вы также передаете ее старое значение (подход оптимистичной блокировки).</p><p>   ◇ Если с момента вызова метода значение переменной отличается от ожидаемого — результатом выполнения будет false.</p><p>   ◇ Для каждого примитивного типа есть атомик</p><p><div class="codebox"><pre>    <span style="color:#7f0044;font-weight:400">final</span> AtomicInteger atomicInteger = <span style="color:#ff9d00;font-weight:700">new</span> AtomicInteger(<span style="color:#ff0044;font-weight:400">42</span>);<br />        <span style="color:#0088ff;font-weight:400">// ..........</span><br />    <span style="color:#ff9d00;font-weight:700">for</span> (<span style="color:#7f0044;font-weight:400">int</span> i = <span style="color:#ff0044;font-weight:400">0</span>; i &lt; <span style="color:#ff0044;font-weight:400">10</span>; i++) {<br />        <span style="color:#ff9d00;font-weight:700">new</span> Thread(() -&gt; {<br />            <span style="color:#0088ff;font-weight:400">// ......</span><br />            atomicInteger.set(<span style="color:#ff0044;font-weight:400">1254</span>); <span style="color:#0088ff;font-weight:400">// Эта операция будет выполняться атомарно, она не сломает нам данные</span><br />            <span style="color:#0088ff;font-weight:400">// ......</span><br />        }).start();<br />    }</pre></div></p><p></p><p><div class="codebox"><pre>        <span style="color:#7f0044;font-weight:400">final</span> AtomicReference&lt;Sample&gt; sampleAtomicReference = <span style="color:#ff9d00;font-weight:700">new</span> AtomicReference&lt;&gt;(<span style="color:#ff9d00;font-weight:700">new</span> Sample());<br />        <span style="color:#0088ff;font-weight:400">// .........</span><br />        <span style="color:#ff9d00;font-weight:700">for</span> (<span style="color:#7f0044;font-weight:400">int</span> i = <span style="color:#ff0044;font-weight:400">0</span>; i &lt; <span style="color:#ff0044;font-weight:400">10</span>; i++) {<br />            <span style="color:#ff9d00;font-weight:700">new</span> Thread(() -&gt; {<br />                <span style="color:#0088ff;font-weight:400">// .........</span><br />                sampleAtomicReference.set(<span style="color:#ff9d00;font-weight:700">new</span> Sample());<br />                <span style="color:#0088ff;font-weight:400">// .........</span><br />            }).start();<br />        }</pre></div></p><p></p><p><h2>Semaphore</h2></p><p>Синхронизатор Semaphore реализует шаблон синхронизации Семафор. Чаще всего, семафоры необходимы, когда нужно ограничить доступ к некоторому общему ресурсу. В конструктор этого класса (Semaphore(int permits) или Semaphore(int permits, boolean fair)) обязательно передается количество потоков, которому семафор будет разрешать одновременно использовать заданный ресурс.</p><p>Доступ управляется с помощью счётчика: изначально значение счетчика равно int permits, когда поток входит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из блока (в качестве примера из жизни с permits = 1, можно привести очередь в кабинет в поликлинике: когда пациент покидает кабинет, мигает лампа, и заходит следующий пациент).</p><p>Разрешает находится в критической секции только определенному числу потоков.</p><p></p><p><h2>CountDownLatch </h2>(одноразовый)</p><p>(замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность. В конструктор CountDownLatch (CountDownLatch(int count)) обязательно передается количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.</p><p>Блокирует критическую секцию, пока не сработают все условия (уменьшится значение счетчика до 0)</p><p></p><p><h2>CyclicBarrier</h2></p><p>CyclicBarrier реализует шаблон синхронизации Барьер. Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструктор барьера (CyclicBarrier(int parties) и CyclicBarrier(int parties, Runnable barrierAction)) обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены». </p><p>Барьер похож на CountDownLatch, но главное различие между ними в том, что Вы не можете заново использовать «замок» после того, как его счетчик достигнет нуля, а барьер вы можете использовать снова, даже после того, как он сломается.</p><p>CyclicBarrier является альтернативой метода join(), который «собирает» потоки только после того, как они выполнялись.</p><p></p><p><h2>Exchanger&lt;V&gt;</h2></p><p>Exchanger (обменник) может понадобиться, для того, чтобы обмениваться данными между двумя потоками в определенной точке работы обоих потоков. Обменник — обобщенный класс, он параметризуется типом объекта для передачи.</p><p>Обменник является точкой синхронизации пары потоков: поток, вызывающий у обменника метод exchange() блокируется и ждет другой поток. Когда другой поток вызовет тот же метод, произойдет обмен объектами: каждая из них получит аргумент другой в методе exchange().</p><p>Стоит отметить, что обменник поддерживает передачу null значения. Это дает возможность использовать его для передачи объекта в одну сторону, или, просто как точку синхронизации двух потоков.</p><p></p><p><h2>Phaser</h2></p><p>Phaser , как и CyclicBarrier, является реализацией шаблона синхронизации Барьер, но, в отличии от CyclicBarrier, предоставляет больше гибкости. Этот класс позволяет синхронизировать потоки, представляющие отдельную фазу или стадию выполнения общего действия. Как и CyclicBarrier, Phaser является точкой синхронизации, в которой встречаются потоки-участники. Когда все стороны прибыли, Phaser переходит к следующей фазе и снова ожидает ее завершения. </p><p>Если сравнить Phaser и CyclicBarrier, то можно выделить следующие важные особенности Phaser:</p><p>• Каждая фаза (цикл синхронизации) имеет номер;</p><p>• Количество сторон-участников жестко не задано и может меняться: поток может регистрироваться в качестве участника и отменять свое участие;</p><p>• Участник не обязан ждать, пока все остальные участники соберутся на барьере. Чтобы продолжить свою работу достаточно сообщить о своем прибытии;</p><p>• Случайные свидетели могут следить за активностью в барьере;</p><p>• Поток может и не быть стороной-участником барьера, чтобы ожидать его преодоления;</p><p>• У фазера нет опционального действия.</p><p></p><p>Объект Phaser создается с помощью одного из конструкторов:</p><p>• Phaser()</p><p>• Phaser(int parties)</p><p>Параметр parties указывает на количество сторон-участников, которые будут выполнять фазы действия. Первый конструктор создает объект Phaser без каких-либо сторон, при этом барьер в этом случае тоже «закрыт». Второй конструктор регистрирует передаваемое в конструктор количество сторон. Барьер открывается когда все стороны прибыли, или, если снимается последний участник. </p><p></p><p>Основные методы:</p><p>• <strong>int register()</strong> — регистрирует нового участника, который выполняет фазы. Возвращает номер текущей фазы;</p><p>• <strong>int getPhase()</strong> — возвращает номер текущей фазы;</p><p>• <strong>int arriveAndAwaitAdvance()</strong> — указывает что поток завершил выполнение фазы. Поток приостанавливается до момента, пока все остальные стороны не закончат выполнять данную фазу. Точный аналог CyclicBarrier.await(). Возвращает номер текущей фазы;</p><p>• <strong>int arrive()</strong> — сообщает, что сторона завершила фазу, и возвращает номер фазы. При вызове данного метода поток не приостанавливается, а продолжает выполняться;</p><p>• <strong>int arriveAndDeregister()</strong> — сообщает о завершении всех фаз стороной и снимает ее с регистрации. Возвращает номер текущей фазы;</p><p>• <strong>int awaitAdvance(int phase)</strong> — если phase равно номеру текущей фазы, приостанавливает вызвавший его поток до ее окончания. В противном случае сразу возвращает аргумент.</p><p></p><p>---------------------------------------------------------------------------------------</p><p></p><p>Callable - интерфейс, который возвращает какое-то значение (есть метод call() ). Этот интерфейс создан для многопоточности так же как и Runnable. Отличием от Runnable является то, что Callable возвращает какой-то результат.</p><p></p><p><strong>Callable&lt;String&gt; c = </strong><strong><span style="color:#cc7832;">new </span></strong><strong>Callable&lt;String&gt;() {</strong></p><p><strong>    </strong><strong><span style="color:#bbb529;">@Override</span></strong></p><p><strong><span style="color:#bbb529;">    </span></strong><strong><span style="color:#cc7832;">public </span></strong><strong>String </strong><strong><span style="color:#003992;">call</span></strong><strong>() </strong><strong><span style="color:#cc7832;">throws </span></strong><strong>Exception {</strong></p><p><strong>        </strong><strong><span style="color:#808080;">// To do something</span></strong></p><p><strong><span style="color:#808080;">        </span></strong><strong><span style="color:#cc7832;">return </span></strong><strong><span style="color:#6a8759;">&quot;Success&quot;</span></strong><strong><span style="color:#cc7832;">;</span></strong></p><p><strong><span style="color:#cc7832;">    </span></strong><strong>}</strong></p><p><strong>}</strong><strong><span style="color:#cc7832;">;</span></strong><strong></strong></p><p><strong>Future&lt;String&gt; submit = exetutorService.submit(c)</strong><strong><span style="color:#cc7832;">;</span></strong><strong></strong></p><p><strong></strong></p><p>---------------------------------------------------------------------------------------</p><p>Метод <strong>parallel()</strong></p><p><strong></strong></p><p><strong>List.</strong><em><strong>of</strong></em><strong>(</strong><strong><span style="color:#6a8759;">&quot;1&quot;</span></strong><strong><span style="color:#cc7832;">, </span></strong><strong><span style="color:#6a8759;">&quot;2&quot;</span></strong><strong><span style="color:#cc7832;">, </span></strong><strong><span style="color:#6a8759;">&quot;3&quot;</span></strong><strong><span style="color:#cc7832;">, </span></strong><strong><span style="color:#6a8759;">&quot;4&quot;</span></strong><strong><span style="color:#cc7832;">, </span></strong><strong><span style="color:#6a8759;">&quot;5&quot;</span></strong><strong><span style="color:#cc7832;">, </span></strong><strong><span style="color:#6a8759;">&quot;6&quot;</span></strong><strong><span style="color:#cc7832;">, </span></strong><strong><span style="color:#6a8759;">&quot;7&quot;</span></strong><strong>)  // </strong>Либо<strong> Files.</strong><em><strong>readAllLines</strong></em><strong>(Path.</strong><em><strong>of</strong></em><strong>(</strong><strong><span style="color:#6a8759;">&quot;...&quot;</span></strong><strong>))</strong><strong><span style="color:#cc7832;"></span></strong></p><p><strong><span style="color:#cc7832;"></span></strong><strong>        .stream() </strong><strong><span style="color:#808080;">// Преобазуем List в поток данных</span></strong></p><p><strong><span style="color:#808080;">        </span></strong><strong>.parallel() </strong><strong><span style="color:#808080;">// Этот метод сделает обработку этого списка в разных потоках</span></strong></p><p><strong><span style="color:#808080;">                    // операции будут выполняться не под ряд</span></strong></p><p><strong><span style="color:#808080;">        </span></strong><strong>.map(Integer::</strong><em><strong>valueOf</strong></em><strong>) </strong><strong><span style="color:#808080;">// Преобразуем строку в Integer</span></strong></p><p><strong><span style="color:#808080;">        </span></strong><strong>.toList()</strong><strong><span style="color:#cc7832;">;</span></strong><strong></strong></p><p><strong></strong></p></div>
</body>
</html>
